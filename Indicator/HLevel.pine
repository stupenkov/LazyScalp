// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © anton8787

//@version=5
indicator("HLevel 2.0", overlay = true, max_lines_count = 50)

// H1
int h1Width = input.int(defval =  1, title =  "Width", minval =  1, maxval =  10, step =  1, inline="h1Style", group = "H1")
color h1Color = input.color(defval = #3179f5, title =  "Color line H1",  inline="h1Style", group = "H1")
float lineSpacingError = input.float(defval = 0.2, title = "Line spacing error, %", group = "H1") / 100

// D1
int d1Width = input.int(defval =  2, title =  "Width", minval =  1, maxval =  10, step =  1, inline="d1Style", group = "D1")
color d1Color = input.color(defval = color.lime, title =  "Color line D1",  inline="d1Style", group = "D1")

int timeToRemoveLine = input.int(defval =  60, title =  "Time to remove line, min", minval =  1, step =  1, group = "common") * 60
int nearLevelCoef = input.int(defval =  20, title =  "Near level coefficient", step =  1, group = "common") 
float maxLevelDistanceCoef = input.float(defval =  1.0, title =  "Max level distance coefficient", step =  0.01, group = "common") 
int dayVolumeLimit = input.int(defval =  100, title =  "Day volume limit, million", step =  1, group = "common") * 1000000
color brakeLevelColor = input.color(defval = color.gray, title = "Brake level color", group = "common")

float firstDistanceLevelCoef = input.float(defval = 1, title = "Distance first level coefficient")
float secondDistanceLevelCoef = input.float(defval = 2, title = "Distance first level coefficient")

bool showAdditionalInfo = input.bool(defval = true, title = "Show additional info", group = "visual")
bool showDebugInfo = input.bool(defval = false, title = "Show debug info", group = "visual")

var lineTransparent = 80
var c_highLevel = 'highLevel'
var c_lowLevel = 'lowLevel'

type levelLine
    string kind
    int barIndex
    int crossBarIndex = -1
    float price
    line lineId
    string timeFrame
    bool hasNearLevel
    bool hide

var array<levelLine> levelLines = array.new<levelLine>()

int seconds = timeframe.in_seconds(timeframe.period)
int historyBars = math.floor(timeToRemoveLine / seconds)

int h1PivotBars = math.floor(3600 * 1.5 / seconds)
int d1PivotBars = math.floor(3600 * 24 * 1.5 / seconds)

//label.new(bar_index, high, str.tostring(h1PivotBars))
float h1HPivot = ta.pivothigh(high, h1PivotBars, h1PivotBars)
float d1HPivot = ta.pivothigh(high, d1PivotBars, d1PivotBars)
float h1LPivot = ta.pivotlow(low, h1PivotBars, h1PivotBars)
float d1LPivot = ta.pivotlow(low, d1PivotBars, d1PivotBars)

float atrD1 = request.security(syminfo.tickerid, 'D', ta.atr(7))
float volatility = (atrD1 / nearLevelCoef) / close
float maxDistance = atrD1 * maxLevelDistanceCoef

float closeHigh = 99999999999999999
float closeLow = 99999999999999999
string closeTfHigh = na
string closeTfLow = na
var color middleTableColor = #ff9800
var color successTableColor = #3c963f
var tableBgColor = #363636

//====================================================================================
// Calculate day volume
//====================================================================================
// FORMATTER
formater(data) =>
    if str.length(data) > 11
        str.substring(data, 0, 3) + " B"
    else if str.length(data) > 10
        str.substring(data, 0, 2) + " B"
    else if str.length(data) > 9
        str.substring(data, 0, 1) + " B"
    else if str.length(data) > 8
        str.substring(data, 0, 3) + " M"
    else if str.length(data) > 7
        str.substring(data, 0, 2) + " M"
    else if str.length(data) > 6
        str.substring(data, 0, 1) + " M"
    else if str.length(data) > 5
        str.substring(data, 0, 3) + " K"
    else if str.length(data) > 4
        str.substring(data, 0, 2) + " K"
    else if str.length(data) > 3
        str.substring(data, 0, 1) + " K"

d1 = request.security(syminfo.ticker, "60", volume * close)
d2 = request.security(syminfo.ticker, "60", volume[1] * close[1])
d3 = request.security(syminfo.ticker, "60", volume[2] * close[2])
d4 = request.security(syminfo.ticker, "60", volume[3] * close[3])
d5 = request.security(syminfo.ticker, "60", volume[4] * close[4])
d6 = request.security(syminfo.ticker, "60", volume[5] * close[5])
d7 = request.security(syminfo.ticker, "60", volume[6] * close[6])
d8 = request.security(syminfo.ticker, "60", volume[7] * close[7])
d9 = request.security(syminfo.ticker, "60", volume[8] * close[8])
d10 = request.security(syminfo.ticker, "60", volume[9] * close[9])
d11 = request.security(syminfo.ticker, "60", volume[10] * close[10])
d12 = request.security(syminfo.ticker, "60", volume[11] * close[11])
d13 = request.security(syminfo.ticker, "60", volume[12] * close[12])
d14 = request.security(syminfo.ticker, "60", volume[13] * close[13])
d15 = request.security(syminfo.ticker, "60", volume[14] * close[14])
d16 = request.security(syminfo.ticker, "60", volume[15] * close[15])
d17 = request.security(syminfo.ticker, "60", volume[16] * close[16])
d18 = request.security(syminfo.ticker, "60", volume[17] * close[17])
d19 = request.security(syminfo.ticker, "60", volume[18] * close[18])
d20 = request.security(syminfo.ticker, "60", volume[19] * close[19])
d21 = request.security(syminfo.ticker, "60", volume[20] * close[20])
d22 = request.security(syminfo.ticker, "60", volume[21] * close[21])
d23 = request.security(syminfo.ticker, "60", volume[22] * close[22])
d24 = request.security(syminfo.ticker, "60", volume[23] * close[23])

dayVolNumber = math.round(d1 + d2 + d3 + d4 + d5 + d6 + d7 + d8 + d9 + d10 + d11 + d12 + d13 + d14 + d15 + d16 + d17 + d18 + d19 + d20 + d21 + d22 + d23 + d24)
dayVol = str.tostring(dayVolNumber)
dayVol := formater(dayVol)

//====================================================================================
// Create level
//====================================================================================
if not na(h1HPivot)
    levelLine level = levelLine.new(
      kind = c_highLevel, 
      barIndex =  bar_index - h1PivotBars,
      price = h1HPivot,
      timeFrame = "60")
    array.unshift(levelLines, level)

if not na(h1LPivot)
    levelLine level = levelLine.new(
      kind = c_lowLevel, 
      barIndex =  bar_index - h1PivotBars,
      price = h1LPivot,
      timeFrame = "60")
    array.unshift(levelLines, level)

//====================================================================================
// Mark day level
//====================================================================================
if not na(d1HPivot) and array.size(levelLines) > 0
    for i = 0 to array.size(levelLines) - 1
        levelLine level = array.get(levelLines, i)
        if level.kind == c_highLevel and level.price == d1HPivot
            level.timeFrame := 'D'

if not na(d1LPivot) and array.size(levelLines) > 0
    for i = 0 to array.size(levelLines) - 1
        levelLine level = array.get(levelLines, i)
        if level.kind == c_lowLevel and level.price == d1LPivot
            level.timeFrame := 'D'

//====================================================================================
// Mark nearly levels
//====================================================================================
int levelLinesSize = array.size(levelLines) 
if levelLinesSize > 1
    for j = 0 to levelLinesSize - 1 
        levelLine firstLevel = array.get(levelLines, j)
        int counter = 0
        while levelLinesSize > counter
            if counter != j
                levelLine secondLevel = array.get(levelLines, counter)
                float delta = math.min(firstLevel.price, secondLevel.price) * volatility 
                if firstLevel.timeFrame == '60' and secondLevel.timeFrame == '60' 
                    delta /= 2
                if math.abs(firstLevel.price - secondLevel.price) <= delta 
                    // if (firstLevel.barIndex > bar_index - 3000)
                    //     label.new(firstLevel.barIndex, firstLevel.price, str.tostring(volatility * 100) + '%')
                    firstLevel.hasNearLevel := true
                    counter := levelLinesSize 
                else
                    firstLevel.hasNearLevel := false
                    
            counter += 1


//====================================================================================
// Process lines
//====================================================================================
int counter = 0
while array.size(levelLines) > counter
    levelLine level = array.get(levelLines, counter)
    
    // mark crossover
    bool isCross = level.kind == c_highLevel ? level.price < high : level.price > low 
    if isCross and level.crossBarIndex == -1 
        level.crossBarIndex := bar_index
  
    // delete old level
    if (level.crossBarIndex > -1 and level.crossBarIndex < bar_index - historyBars) 
      or (level.timeFrame == '60' and level.barIndex < bar_index - d1PivotBars - 1)
        if not na(level.lineId)
            line.delete(level.lineId)
        array.remove(levelLines, counter)
        continue

    // distance to close levels
    float priceDistance = math.abs(close - level.price) / close
    if level.crossBarIndex == -1 and level.hasNearLevel and level.kind == c_highLevel and priceDistance < closeHigh
        closeHigh := priceDistance
        closeTfHigh := level.timeFrame
    if level.crossBarIndex == -1 and level.hasNearLevel and level.kind == c_lowLevel and priceDistance < closeLow
        closeLow := priceDistance
        closeTfLow := level.timeFrame

    // skip old level
    if (level.barIndex < bar_index - 5000)
        counter +=1
        continue

    // remove far line
    if math.abs(level.price - close) > maxDistance
        if not na (level.lineId)
            line.delete(level.lineId)
        counter +=1
        continue

    // update line
    color color = if level.crossBarIndex != -1
        brakeLevelColor
    else if level.timeFrame == "60"
        h1Color
    else if level.timeFrame == "D"
        d1Color

    int transp = if level.crossBarIndex != -1
        80 
    else if level.hasNearLevel 
        0 
    else 
        lineTransparent
            
    int width = switch level.timeFrame
        "60" => h1Width
        "D" => d1Width

    if na(level.lineId)
        level.lineId := line.new(
          x1 = level.barIndex, 
          y1 = level.price, 
          x2 = level.barIndex + 1, 
          y2 = level.price, 
          extend = extend.right, 
          color = color.new(color, transp), 
          style = line.style_solid, 
          width = width)
    else
        line.set_color(level.lineId, color.new(color, transp))
        line.set_width(level.lineId, width)
    
    counter += 1

//====================================================================================
// Information panel
//====================================================================================
var table panel = table.new(
  position = position.top_right,
  columns = 4,
  rows = 20,
  bgcolor = tableBgColor
  )

var color textColor = color.white
color bgColorH = na
color bgColorL = na
if barstate.islast
    color dayVolumeColor = dayVolNumber > dayVolumeLimit ? color.rgb(60, 150, 63) : color.rgb(173, 47, 47)
    table.cell(table_id = panel, column = 0, row = 1, text = "📶", text_color = textColor, bgcolor = dayVolumeColor)
    table.cell(table_id = panel, column = 1, row = 1, text = "Day volume", text_color = textColor, bgcolor = dayVolumeColor)
    table.cell(table_id = panel, column = 2, row = 1, text = dayVol, text_color = textColor, bgcolor = dayVolumeColor)
    table.cell(table_id = panel, column = 3, row = 1, text = "          ", bgcolor = dayVolumeColor)

    float closeHighPercent = math.round(closeHigh * 100, 2)
    string closeHighText = closeHighPercent > 100 ? "-" : str.tostring(closeHighPercent) + "%"
    bgColorH := if closeHigh < volatility * firstDistanceLevelCoef
        successTableColor
    else if closeHigh < volatility * secondDistanceLevelCoef
        middleTableColor
    else 
        na
    table.cell(table_id = panel, column = 0, row = 2, text = "🔼", text_color = textColor, bgcolor = bgColorH)
    table.cell(table_id = panel, column = 1, row = 2, text = "Strong high", text_color = textColor, bgcolor = bgColorH, width = 7)
    table.cell(table_id = panel, column = 2, row = 2, text = closeHighText, text_color = textColor, bgcolor = bgColorH, width = 4)
    table.cell(table_id = panel, column = 3, row = 2, bgcolor = bgColorH)

    float closeLowPercent = math.round(closeLow * 100, 2)
    string closeLowText = closeLowPercent > 100 ? "-" : str.tostring(closeLowPercent) + "%"
    bgColorL := if closeLow < volatility * firstDistanceLevelCoef
        successTableColor
    else if closeLow < volatility * secondDistanceLevelCoef
        middleTableColor
    else 
        na
    table.cell(table_id = panel, column = 0, row = 3, text = "🔽", text_color = textColor, bgcolor = bgColorL)
    table.cell(table_id = panel, column = 1, row = 3, text = "Strong low", text_color = textColor, bgcolor = bgColorL)
    table.cell(table_id = panel, column = 2, row = 3, text = closeLowText, text_color = textColor, bgcolor = bgColorL)
    table.cell(table_id = panel, column = 3, row = 3, bgcolor = bgColorL)    
    
    if showAdditionalInfo
        table.cell(table_id = panel, column = 1, row = 4, text = "AVG day ATR", text_color = textColor)
        table.cell(table_id = panel, column = 2, row = 4, text = str.tostring(math.round_to_mintick(atrD1)), text_color = textColor)

        table.cell(table_id = panel, column = 1, row = 5, text = "Volatility, %", text_color = textColor)
        table.cell(table_id = panel, column = 2, row = 5, text = str.tostring(math.round(volatility * 100, 2)), text_color = textColor)

        table.cell(table_id = panel, column = 1, row = 6, text = "Max. dist. to lvl", text_color = textColor)
        table.cell(table_id = panel, column = 2, row = 6, text = str.tostring(math.round_to_mintick(maxDistance)), text_color = textColor)

    if showDebugInfo
        table.cell(table_id = panel, column = 0, row = 7, text = "firstDistanceLevel", bgcolor = color.aqua)
        table.cell(table_id = panel, column = 1, row = 7, text = str.tostring(math.round(volatility * firstDistanceLevelCoef * 100, 2)), bgcolor = color.aqua)
        
        table.cell(table_id = panel, column = 0, row = 8, text = "secondDistanceLevel", bgcolor = color.aqua)
        table.cell(table_id = panel, column = 1, row = 8, text = str.tostring(math.round(volatility * secondDistanceLevelCoef * 100, 2)), bgcolor = color.aqua)

//====================================================================================
// Level power panel
//====================================================================================
// var table powerPanel = table.new(
//   position = position.middle_right,
//   columns = 4,
//   rows = 3,
//   bgcolor = #363636,
//   border_color = color.rgb(197, 197, 197),
//   border_width = 1,
//   frame_color = color.rgb(197, 197, 197),
//   frame_width = 1)

// color tfColorH = na
// color tfColorL = na

// if not na(bgColorH)
//     tfColorH := switch closeTfHigh 
//         'D' => color.rgb(60, 150, 63)
//         '60' => color.orange

// if not na(bgColorL)
//     tfColorL := switch closeTfLow
//         'D' => color.rgb(60, 150, 63)
//         '60' => color.orange

// if barstate.islast
//     // header
//     table.cell(table_id = powerPanel, column = 0, row = 0, text = "Level", text_color = textColor, width = 4)
//     table.cell(table_id = powerPanel, column = 1, row = 0, text = "D", text_color = textColor) // distance too level
//     table.cell(table_id = powerPanel, column = 2, row = 0, text = "T", text_color = textColor) // time frame
//     // table.cell(table_id = powerPanel, column = 3, row = 0, text = "V", text_color = textColor) // traded volume

//     // high
//     table.cell(table_id = powerPanel, column = 0, row = 1, text = "High", text_color = textColor)
//     table.cell(table_id = powerPanel, column = 1, row = 1, text_color = textColor, bgcolor = bgColorH)
//     table.cell(table_id = powerPanel, column = 2, row = 1, text_color = textColor, bgcolor = tfColorH)

//     // low
//     table.cell(table_id = powerPanel, column = 0, row = 2, text = "Low", text_color = textColor)
//     table.cell(table_id = powerPanel, column = 1, row = 2, text_color = textColor, bgcolor = bgColorL)
//     table.cell(table_id = powerPanel, column = 2, row = 2, text_color = textColor, bgcolor = tfColorL)

//====================================================================================
// Description panel
//====================================================================================
var table descPanel = table.new(
  position = position.bottom_right,
  columns = 2,
  rows = 10)

if barstate.islast
    table.cell(table_id = descPanel, column = 0, row = 0, text = "Legends", text_color = textColor, text_halign = text.align_center)
    table.cell(table_id = descPanel, column = 1, row = 0, bgcolor = tableBgColor)
    table.merge_cells(table_id = descPanel, start_column = 0, start_row = 0, end_column = 1, end_row = 0)
    
    table.cell(table_id = descPanel, column = 0, row = 1, text = "Strong local level", text_halign = text.align_right, text_color = textColor)
    table.cell(table_id = descPanel, column = 1, row = 1, bgcolor = h1Color)
    
    table.cell(table_id = descPanel, column = 0, row = 2, text = "Local extremum", text_halign = text.align_right, text_color = textColor)
    table.cell(table_id = descPanel, column = 1, row = 2, bgcolor = color.new(h1Color, lineTransparent))

    table.cell(table_id = descPanel, column = 0, row = 3, text = "Strong global level", text_halign = text.align_right, text_color = textColor)
    table.cell(table_id = descPanel, column = 1, row = 3, bgcolor = d1Color)

    table.cell(table_id = descPanel, column = 0, row = 4, text = "Global extremum", text_halign = text.align_right, text_color = textColor)
    table.cell(table_id = descPanel, column = 1, row = 4, bgcolor = color.new(d1Color, lineTransparent))

    table.cell(table_id = descPanel, column = 0, row = 5, text = "Brake level", text_halign = text.align_right, text_color = textColor)
    table.cell(table_id = descPanel, column = 1, row = 5, bgcolor = color.new(brakeLevelColor, lineTransparent))
